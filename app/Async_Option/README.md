# Async Options

Async Options is a library that provides APIs in both in WordPress and Svelte to make passing data seamless between the WordPress backend and the Svelte frontend.

## Quick Tour

Async Options differ from regular options in that they must be explicitly registered using the Async Option Registry.

Having a streamlined way to register these options allows us to:

- Be clear about what options are available
- Ensure that any necessary transformation/validation/sanitization actions are performed at predictable times
- Provide a structured way to pass the option data to the frontend on page load
- Automatically generate REST API CRUD endpoints that can be used by the Svelte front-end
- Automatically set-up a nonce for every option that is registered
- Have typed Svelte options stores that automatically sync with WordPress Options

### Quick Setup

As an example, I'm going to set-up a new option called `widget_status` that will be used to determine if a widget is enabled or not.

#### Step 1: Register the Option in PHP

The snippet below is going to:

- Ensure that the value is sanitized both when saving and when retrieving the option from the database.
- Create an endpoint `/wp-json/widget-plugin/widget-status` that's going to accept al REST API requests.
- Setup and take care of nonce validation

```php
	class Widget_Status extends Async_Option_Template {

		// A sanitize method is called before the option is saved to the database.
		public function sanitize( $value ): bool {
			return filter_var( $value, FILTER_VALIDATE_BOOLEAN );
		}

		// Transform the value when retrieving the option from the database.
		public function transform( $value ) {
			return filter_var( $value, FILTER_VALIDATE_BOOLEAN );
		}

	}

	// Registry is a Singleton based on the key provided. A new instance is going to be created if one doesn't exist.
	Registry::get_instance( 'widget_plugin' )
			->register( 'widget_status', new Widgets_Status() );
```

#### Step 2: Pass data on page load

Script names and locations can vary depending on the plugin, so a little bit of setup is necessary to tell Async Options which script to attach to.

To do this, use `Async_Options::setup()` method:

```php
// This only needs to happen in the Admin Dashboard:
add_action( 'admin_init', function() {
	// Notice that widget_plugin matches the registry key.
	// `widget-plugin-scripts` in this example is the script file name
	// that's enqueued by WordPress in the plugin page.
	Async_Options::setup( 'widget_plugin', 'widget-plugin-scripts' );
} );
```

#### Step 3: Register the option in Svelte

The option is passed to the front-end via `window.widget_plugin` global variables.

To ensure that the values are properly typed and match our expectations, we're going to use [Zod](https://zod.dev):

```ts
const Widget_Options = z.object({
	// This is required for all Async_Options instances.
	rest_api: z.object({
		value: z.string().url(),
		nonce: z.string(),
	}),

	// This is the template that all Async Options should follow:
	// Each Async Option that's registered is going to be an object with two keys:
	// - `value`: The value of the option
	// - `nonce`: The nonce for the option
	widget_status: z.object({
		// We're the value of status to be a boolean, Zod allows us to declare that trigger an error if the value doesn't match our expectation.
		value: z.boolean(),

		// Nonce is always a string and is automatically generated by in the Endpoint PHP Class.
		nonce: z.string(),
	}),
});

// window.widget_plugin is the variable, but it's unsafe to read
// This is a helper function that's going to use Widget_Options Zod type to extract the values from the window object and validate them.
const globals = getOptionsFromGlobal("widget_plugin", Widget_Options);

// Now that we're sure that the values are valid, we can set-up options.
const asyncOptions = new Options(globals);

// This is going to set-up a Svelte store that's going to automatically sync back with WordPress any time the value of the option changes.
export const widgetStatus = asyncOptions.createStore(
	"widget_status",
	async ({ value, nonce }) =>
		await api.POST<typeof value>("widget-status", nonce, value.toString())
);
```

#### Step 4: Use the store in components

Registering an async option using `asyncOptions.createStore()` will create a store with two reactive values:

- value: The value of the option. This will dispatch POST requests to the REST API endpoint when the value changes.
- pending: Whether the value is being currently being sent to the server

Here's a simple version of how that would work:

```svelte
<script type="ts">
	import { widgetStatus } from "./widget-options.ts";
	status = widgetStatus.value;
	pending = widgetStatus.pending;
</script>

{#if $pending}
	 ðŸŒŠ I'm updating the value
{/if}

<input type="checkbox" bind:checked={$status} /> Enable Widget
```

That's all there is to it. 

We now can have fully type safe stores that automatically sync front-end and back-end, deal with sanitization, validation, transformation, nonces, REST API and svelte stores by:

1. Creating an Async Option Template based class in PHP
2. Registering the option in PHP
3. Adding a zod type
4. Registering the zod-validated option as a Svelte store

## Clunk

You might have noticed that the registration process is not exactly beautiful. But we can create plugin specific functions that simplify the interaction like so:

```php
function widgetplug_get_option( $name ) {
	return Registry::get_instance( 'widget_plugin' )->get_option( $name );
}

function widgetplug_register_option( $name, $handler ) {
	return Registry::get_instance( 'widget_plugin' )
	               ->regsiter( $name, $handler );
}
```

Now registering new options becomes easy to parse at a glance:

```php
widgetplug_register_option( 'widget_status', new Widget_Status() );
widgetplug_register_option( 'widget_title', new Widget_Text_Field() );
widgetplug_register_option( 'widget_text', new Widget_Text_Field() );
```
